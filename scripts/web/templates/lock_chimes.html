{% extends "base.html" %}
{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/audio_trimmer.css') }}">
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
<script src="{{ url_for('static', filename='js/audio_trimmer.js') }}"></script>
{% endblock %}
{% block content %}
<div class="container">
    <h2>üîî Lock Chimes</h2>
    <div class="status-label {{ mode_class }}">Current Mode: {{ mode_label }}</div>
    
    <!-- Gadget State Indicator -->
    <div id="gadgetStateIndicator" style="display: none; margin: 15px 0; padding: 12px; border-radius: 8px; font-size: 14px;">
        <strong id="gadgetStateTitle"></strong>
        <div id="gadgetStateDetails" style="margin-top: 5px; font-size: 13px;"></div>
    </div>
    
    <!-- iOS Safari Warning -->
    <div id="iosWarning" style="display: none; background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
        <p style="margin: 0; font-size: 14px;"><strong>‚ö†Ô∏è iOS Browser Limitation:</strong> File uploading is only available through Safari when running on iOS. Please open this page in Safari to upload files.</p>
        <p style="margin: 8px 0 0 0; font-size: 13px; color: var(--text-secondary);">Note: Desktop browsers (Windows/Mac/Linux) work normally regardless of browser choice.</p>
    </div>
    
    <!-- Active Lock Chime - Moved to top -->
    {% if active_chime %}
    <div style="background: var(--active-chime-bg); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--active-chime-border);">
        <h3 style="margin: 0 0 10px 0; color: var(--active-chime-heading);">üîä Active Lock Chime</h3>
        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
            <div>
                <strong>{{ active_chime.filename }}</strong><br>
                <span style="color: var(--text-secondary); font-size: 13px;">{{ active_chime.size_str }}</span>
            </div>
            <audio controls preload="none" style="flex: 1; max-width: 300px; height: 30px;">
                <source src="{{ url_for('lock_chimes.play_active_chime') }}?v={{ active_chime.mtime }}" type="audio/wav">
            </audio>
        </div>
    </div>
    {% else %}
    <div class="info-box" style="background-color: #ffebee; border-left: 4px solid #f44336; margin-bottom: 20px;">
        <p style="margin: 0;">‚ö†Ô∏è No active lock chime set. Select a chime from the library below.</p>
    </div>
    {% endif %}
    
    <!-- Upload Controls - Collapsible -->
    <details class="folder-controls" id="chimeUploadControls" style="margin-bottom: 20px;">
        <summary style="cursor: pointer; font-weight: 600; padding: 15px; background: var(--collapsible-section-bg); border-radius: 8px; border-left: 4px solid var(--collapsible-section-border); color: var(--collapsible-section-text); font-size: 18px; list-style: none; user-select: none;">
            <span style="display: inline-block; margin-right: 5px;">‚ñ∂</span> üì§ Upload New Chime
        </summary>
        
        <div style="background: var(--collapsible-content-bg); padding: 15px; border-radius: 0 0 8px 8px; border-left: 4px solid var(--collapsible-section-border); border-right: 1px solid var(--collapsible-section-border); border-bottom: 1px solid var(--collapsible-section-border); margin-top: -8px;">
            <form method="post" action="{{ url_for('lock_chimes.upload_lock_chime') }}" enctype="multipart/form-data" id="chimeUploadForm">
                <input type="hidden" name="pre_trimmed" id="preTrimmedFlag" value="false">
                <input type="hidden" name="original_filename" id="originalFilename" value="">
                <div style="display: flex; gap: 10px; align-items: flex-start; flex-wrap: wrap; margin-bottom: 10px;">
                    <input type="file" name="chime_file" id="chime_file" accept=".wav,.mp3" required 
                           style="padding: 10px; border: 2px solid var(--border-input); border-radius: 4px; background: var(--form-input-bg); flex: 1; min-width: 250px; max-width: 400px; font-size: 14px; color: var(--text-primary);">
                    <button type="submit" class="edit-btn" id="chimeUploadBtn" style="margin: 0; display: none;">üì§ Upload</button>
                </div>
                <p style="margin: 0 0 15px 0; font-size: 12px; color: var(--text-secondary);">
                    WAV or MP3 files - auto-converted to Tesla format (PCM 16-bit, 44.1 kHz, under 1MB)
                </p>
            </form>
            
            <!-- Upload Progress Bar -->
            <div id="chimeUploadProgress" style="display: none; margin-top: 15px;">
                <div style="background: var(--upload-progress-bg); border-radius: 8px; padding: 15px; border: 2px solid var(--btn-primary-bg);">
                    <h4 style="margin: 0 0 10px 0; color: var(--btn-primary-bg);">üì§ Uploading Chime...</h4>
                    <div style="background: var(--upload-progress-bar-bg); border-radius: 4px; height: 30px; overflow: hidden; margin-bottom: 10px;">
                        <div id="chimeProgressBar" style="background: linear-gradient(90deg, #007bff, #0056b3); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">
                            0%
                        </div>
                    </div>
                    <p id="chimeUploadStatus" style="margin: 0; font-size: 13px; color: var(--text-secondary);">Preparing upload...</p>
                </div>
            </div>
        </div>
    </details>
    
    <!-- Audio Trim Editor -->
    <div id="trimEditorSection" class="trim-editor-section" style="display: none;">
        <div class="trim-editor-header">
            <span id="trimEditorTitle">‚úÇÔ∏è Trim & Adjust Audio</span>
            <span id="trimEditorBadge" class="trim-editor-badge" style="display: none;">Editing</span>
        </div>
        
        <!-- Loading State -->
        <div id="trimEditorLoading" class="trim-editor-loading" style="display: none;">
            <div class="trim-editor-spinner"></div>
            <p style="margin-top: 15px;">Decoding audio...</p>
        </div>
        
        <!-- Editor Content -->
        <div id="trimEditorContent" style="display: none;">
            <!-- Warning Message -->
            <div id="trimMessage" class="trim-message" style="display: none;"></div>
            
            <!-- Waveform -->
            <div class="waveform-container">
                <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
            </div>
            
            <!-- Trim Controls -->
            <div class="trim-controls">
                <!-- Start/End Time -->
                <div class="trim-control-row">
                    <div class="trim-control-group">
                        <label class="trim-control-label">
                            Start Time
                            <span class="trim-control-sublabel" id="startTimeDisplay">0.00s</span>
                        </label>
                        <input type="range" id="startTimeSlider" class="trim-slider" min="0" max="100" value="0" step="0.1">
                    </div>
                    <div class="trim-control-group">
                        <label class="trim-control-label">
                            End Time
                            <span class="trim-control-sublabel" id="endTimeDisplay">0.00s</span>
                        </label>
                        <input type="range" id="endTimeSlider" class="trim-slider" min="0" max="100" value="100" step="0.1">
                    </div>
                </div>
                
                <!-- Playback Speed - HIDDEN FOR NOW (pitch preservation needs improvement) -->
                <div class="trim-control-group" style="display: none;">
                    <label class="trim-control-label">
                        Playback Speed
                        <span class="trim-control-sublabel" id="speedDisplay">1.00x</span>
                    </label>
                    <input type="range" id="speedSlider" class="speed-slider" min="0.5" max="2.0" value="1.0" step="0.05">
                </div>
                
                <!-- Volume Normalization -->
                <div class="trim-control-group" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border-input);">
                    <label class="trim-control-label" style="display: flex; align-items: center; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="trimNormalizeVolume" checked style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span>üîä Normalize Volume</span>
                    </label>
                    <div id="trimNormalizationSettings" style="margin-top: 12px;">
                        <div style="margin-bottom: 8px;">
                            <input type="range" id="trimTargetLufs" class="speed-slider" min="0" max="3" value="1" step="1">
                        </div>
                        <div class="slider-labels" style="display: grid; grid-template-columns: repeat(4, 1fr); font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                            <span style="text-align: left;">Broadcast</span>
                            <span style="text-align: center;">Streaming</span>
                            <span style="text-align: center;">Loud</span>
                            <span style="text-align: right;">Maximum</span>
                        </div>
                        <div style="margin-top: 10px; padding: 8px; background: var(--form-input-bg); border-radius: 4px; border: 1px solid var(--border-input);">
                            <strong id="trimCurrentLevel" style="display: block; margin-bottom: 4px; font-size: 13px;">Streaming</strong>
                            <small id="trimLevelDescription" style="color: var(--text-secondary); font-size: 11px;">Recommended for balanced playback</small>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Stats Display -->
            <div class="trim-stats">
                <div class="trim-stats-grid">
                    <div class="trim-stat">
                        <span class="trim-stat-label">Duration</span>
                        <span class="trim-stat-value" id="statDuration">0.0s</span>
                    </div>
                    <div class="trim-stat">
                        <span class="trim-stat-label">Effective Duration</span>
                        <span class="trim-stat-value" id="statEffective">0.0s</span>
                    </div>
                    <div class="trim-stat">
                        <span class="trim-stat-label">File Size</span>
                        <span class="trim-stat-value" id="statFileSize">0 KB</span>
                    </div>
                    <div class="trim-stat">
                        <span class="trim-stat-label">Status</span>
                        <span class="trim-stat-value success" id="statStatus">‚úì Ready</span>
                    </div>
                </div>
            </div>
            
            <!-- Filename Editor -->
            <div style="margin: 15px 0; padding: 15px; background: var(--form-input-bg); border-radius: 8px; border: 2px solid var(--border-input);">
                <label for="trimFilename" style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-primary);">
                    üìù Output Filename:
                </label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="trimFilename" 
                           style="flex: 1; padding: 10px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);"
                           placeholder="Enter filename (without extension)">
                    <span style="color: var(--text-secondary); font-weight: 600;">.wav</span>
                </div>
                <div id="filenameValidation" style="margin-top: 8px; font-size: 13px; display: none;"></div>
            </div>
            
            <!-- Playback Controls -->
            <div class="playback-controls">
                <button id="playBtn" class="play-btn" title="Play preview">
                    <i class="bi bi-play-fill"></i>
                </button>
                <button id="autoFitBtn" class="trim-btn trim-btn-purple">
                    üéØ Auto-Fit to Limits
                </button>
                <button id="resetBtn" class="trim-btn trim-btn-secondary">
                    ‚Ü∫ Reset
                </button>
            </div>
            
            <!-- Action Buttons -->
            <div class="trim-actions">
                <button id="uploadTrimmedBtn" class="trim-btn trim-btn-success">
                    üì§ Upload Trimmed Audio
                </button>
                <button id="cancelTrimBtn" class="trim-btn trim-btn-secondary">
                    ‚úñ Cancel
                </button>
            </div>
        </div>
    </div>
    
    <!-- Chime Scheduler -->
    <details id="scheduler-section" style="margin-bottom: 20px;">
        <summary style="cursor: pointer; font-weight: 600; padding: 15px; background: var(--collapsible-section-bg); border-radius: 8px; border-left: 4px solid var(--collapsible-section-border); color: var(--collapsible-section-text); font-size: 18px; list-style: none;">
            <span style="display: inline-block; margin-right: 5px;">‚ñ∂</span> üìÖ Chime Scheduler {% if schedules %}({{ schedules|length }} schedule{{ 's' if schedules|length != 1 else '' }}){% endif %}
        </summary>
        
        <div style="background: var(--collapsible-content-bg); padding: 15px; border-radius: 0 0 8px 8px; border-left: 4px solid var(--collapsible-section-border); border-right: 1px solid var(--collapsible-section-border); border-bottom: 1px solid var(--collapsible-section-border); margin-top: -8px;">
            <!-- Add New Schedule Form -->
            <details {% if not schedules %}open{% endif %} style="margin-bottom: 15px;" id="schedule-form-details">
                <summary style="cursor: pointer; font-weight: 600; padding: 10px; background: var(--form-input-bg); border-radius: 4px; list-style: none; border: 1px solid var(--border-input);">
                    <span style="display: inline-block; margin-right: 5px;">‚ñ∂</span> <span id="form-title">‚ûï Add New Schedule</span>
                </summary>
            
            <form id="schedule-form" method="post" action="{{ url_for('lock_chimes.add_schedule') }}" style="background: var(--form-input-bg); padding: 15px; border-radius: 4px; margin-top: 10px; border: 1px solid var(--border-input);">
                <div style="display: grid; gap: 15px;">
                    <!-- Schedule Name -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Schedule Name:</label>
                        <input type="text" id="schedule-name" name="schedule_name" placeholder="e.g., Morning Chime" required
                               style="width: 100%; padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; box-sizing: border-box; background: var(--bg-secondary); color: var(--text-primary);">
                    </div>
                    
                    <!-- Chime Selection -->
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Chime:</label>
                        <select id="chime-select" name="chime_filename" required
                                style="width: 100%; padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                            <option value="">-- Select a chime --</option>
                            <option value="RANDOM">üé≤ Random Chime</option>
                            {% for chime in chime_files %}
                                {% if chime.is_valid %}
                                <option value="{{ chime.filename }}">{{ chime.filename }}</option>
                                {% endif %}
                            {% endfor %}
                        </select>
                    </div>
                    
                    <!-- Schedule Type Selection -->
                    <div>
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Schedule Type:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <label style="display: flex; align-items: center; padding: 8px 12px; background: var(--form-label-bg); border-radius: 4px; cursor: pointer; user-select: none; border: 1px solid var(--border-input);">
                                <input type="radio" name="schedule_type" value="weekly" class="schedule-type-radio" checked style="margin-right: 6px;">
                                <span>üìÖ Days of Week</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 8px 12px; background: var(--form-label-bg); border-radius: 4px; cursor: pointer; user-select: none; border: 1px solid var(--border-input);">
                                <input type="radio" name="schedule_type" value="date" class="schedule-type-radio" style="margin-right: 6px;">
                                <span>üìÜ Specific Date</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 8px 12px; background: var(--form-label-bg); border-radius: 4px; cursor: pointer; user-select: none; border: 1px solid var(--border-input);">
                                <input type="radio" name="schedule_type" value="holiday" class="schedule-type-radio" style="margin-right: 6px;">
                                <span>üéâ US Holiday</span>
                            </label>
                            <label style="display: flex; align-items: center; padding: 8px 12px; background: var(--form-label-bg); border-radius: 4px; cursor: pointer; user-select: none; border: 1px solid var(--border-input);">
                                <input type="radio" name="schedule_type" value="recurring" class="schedule-type-radio" style="margin-right: 6px;">
                                <span>üîÑ Recurring Rotation</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Interval Selection (for recurring schedules) -->
                    <div id="interval-selection" class="schedule-type-field" style="display: none;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Rotation Frequency:</label>
                        <select id="interval-select" name="interval" style="width: 100%; padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                            <option value="">-- Select frequency --</option>
                            {% for interval_value, interval_name in recurring_intervals.items() %}
                            <option value="{{ interval_value }}">{{ interval_name }}</option>
                            {% endfor %}
                        </select>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: var(--text-secondary);">
                            ‚ÑπÔ∏è Recurring schedules always use <strong>Random Chime</strong> and automatically avoid repeating the currently active chime
                        </p>
                    </div>
                    
                    <!-- Days Selection (for weekly schedules) -->
                    <div id="days-selection" class="schedule-type-field">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Days:</label>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            {% for day in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] %}
                            <label style="display: flex; align-items: center; padding: 8px 12px; background: var(--form-label-bg); border-radius: 4px; cursor: pointer; user-select: none; border: 1px solid var(--border-input);">
                                <input type="checkbox" name="days" value="{{ day }}" class="day-checkbox" id="day-{{ day }}" style="margin-right: 6px;">
                                <span>{{ day[:3] }}</span>
                            </label>
                            {% endfor %}
                        </div>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: var(--text-secondary);">Select at least one day</p>
                    </div>
                    
                    <!-- Date Selection (for date schedules) -->
                    <div id="date-selection" class="schedule-type-field" style="display: none;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Date (Month/Day):</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="month-select" name="month" style="padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                                <option value="">Month</option>
                                <option value="1">January</option>
                                <option value="2">February</option>
                                <option value="3">March</option>
                                <option value="4">April</option>
                                <option value="5">May</option>
                                <option value="6">June</option>
                                <option value="7">July</option>
                                <option value="8">August</option>
                                <option value="9">September</option>
                                <option value="10">October</option>
                                <option value="11">November</option>
                                <option value="12">December</option>
                            </select>
                            <select id="day-select" name="day" style="padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                                <option value="">Day</option>
                                {% for d in range(1, 32) %}
                                <option value="{{ d }}">{{ d }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: var(--text-secondary);">Chime will play every year on this date</p>
                    </div>
                    
                    <!-- Holiday Selection (for holiday schedules) -->
                    <div id="holiday-selection" class="schedule-type-field" style="display: none;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Holiday:</label>
                        <select id="holiday-select" name="holiday" style="width: 100%; padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                            <option value="">-- Select a holiday --</option>
                            {% for holiday in holidays %}
                            <option value="{{ holiday.name }}">{{ holiday.name }} ({{ holiday.month }}/{{ holiday.day }})</option>
                            {% endfor %}
                        </select>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: var(--text-secondary);">Chime will play at 12:00 AM on the holiday</p>
                    </div>
                    
                    <!-- Time Selection (12-hour format) - hidden for holidays -->
                    <div id="time-selection">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Time:</label>
                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <select id="hour-select" name="hour" required style="padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                                {% for h in range(1, 13) %}
                                <option value="{{ h }}" {% if h == 12 %}selected{% endif %}>{{ h }}</option>
                                {% endfor %}
                            </select>
                            <span style="font-weight: bold;">:</span>
                            <select id="minute-select" name="minute" required style="padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                                {% for m in range(0, 60, 5) %}
                                <option value="{{ '%02d'|format(m) }}" {% if m == 0 %}selected{% endif %}>{{ '%02d'|format(m) }}</option>
                                {% endfor %}
                            </select>
                            <select id="ampm-select" name="am_pm" required style="padding: 8px; border: 2px solid var(--border-input); border-radius: 4px; font-size: 14px; background: var(--bg-secondary); color: var(--text-primary);">
                                <option value="AM" id="ampm-am-option" selected>AM</option>
                                <option value="PM" id="ampm-pm-option">PM</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Enable Schedule -->
                    <div>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="enabled-checkbox" name="enabled" value="true" checked style="margin-right: 8px;">
                            <span style="font-weight: 600;">Enable this schedule immediately</span>
                        </label>
                    </div>
                    
                    <!-- Submit Button -->
                    <div>
                        <button type="submit" id="submit-btn" class="edit-btn" style="margin: 0; padding: 12px 25px;">üíæ Save Schedule</button>
                        <button type="button" id="cancel-btn" class="btn-delete" style="margin-left: 10px; display: none; padding: 12px 25px;" onclick="cancelEdit()">‚ùå Cancel</button>
                    </div>
                </div>
            </form>
            </details>
        
        <!-- Existing Schedules List -->
        {% if schedules %}
        <div style="margin-top: 15px;">
            <h4 style="margin: 0 0 10px 0;">Active Schedules:</h4>
            {% for schedule in schedules %}
            <div style="background: var(--form-input-bg); padding: 12px; border-radius: 4px; margin-bottom: 10px; border-left: 4px solid {% if schedule.enabled %}var(--active-chime-border){% else %}var(--text-muted){% endif %}; border: 1px solid var(--border-input);">
                <div style="display: flex; justify-content: space-between; align-items: start; flex-wrap: wrap; gap: 10px;">
                    <div style="flex: 1; min-width: 200px;">
                        <div style="font-weight: 600; margin-bottom: 4px;">
                            {{ schedule.name }}
                            {% if not schedule.enabled %}
                            <span style="background: var(--status-unknown-bg); color: var(--status-unknown-text); padding: 2px 6px; border-radius: 3px; font-size: 11px; margin-left: 6px;">DISABLED</span>
                            {% endif %}
                        </div>
                        <div style="font-size: 13px; color: var(--text-secondary);">
                            <div>üîî {% if schedule.chime_filename == 'RANDOM' %}üé≤ Random Chime{% else %}{{ schedule.chime_filename }}{% endif %}</div>
                            <div>‚è∞ {{ format_schedule(schedule) }}</div>
                            {% if schedule.last_run %}
                            <div style="color: var(--text-muted); font-size: 12px; margin-top: 2px;">
                                üìä Last run: {{ format_last_run(schedule.last_run) }}
                            </div>
                            {% endif %}
                        </div>
                    </div>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button type="button" onclick="editSchedule({{ schedule.id }})" class="edit-btn" style="padding: 6px 10px; font-size: 13px; margin: 0;">‚úèÔ∏è Edit</button>
                        <form method="post" action="{{ url_for('lock_chimes.toggle_schedule', schedule_id=schedule.id) }}" style="display: inline;">
                            <button type="submit" class="present-btn" style="padding: 6px 10px; font-size: 13px; margin: 0;">
                                {% if schedule.enabled %}‚è∏Ô∏è Disable{% else %}‚ñ∂Ô∏è Enable{% endif %}
                            </button>
                        </form>
                        <form method="post" action="{{ url_for('lock_chimes.delete_schedule', schedule_id=schedule.id) }}" 
                              style="display: inline;" onsubmit="return confirm('Delete schedule \'{{ schedule.name | replace("'", "\\'") }}\'?');">
                            <button type="submit" class="btn-delete" style="padding: 6px 10px; font-size: 13px; margin: 0;">üóëÔ∏è</button>
                        </form>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        {% else %}
        <p style="margin: 10px 0 0 0; color: var(--text-secondary); font-size: 14px;">No schedules configured. Add one above to automatically change chimes at specific times.</p>
        {% endif %}
        
        <div style="background: var(--msg-info-bg); padding: 10px; border-radius: 4px; margin-top: 15px; font-size: 13px; border: 1px solid var(--collapsible-section-border); color: var(--msg-info-text);">
            <strong>‚ÑπÔ∏è How it works:</strong> Schedules run automatically every minute. The most recent schedule for each day will be active. Chimes change without interrupting Tesla recording!
        </div>
        </div>
    </details>
    
    <!-- Chime Library -->
    <h3 style="margin: 20px 0 10px 0;">üìö Chime Library</h3>
    {% if chime_files %}
    <div class="video-table-container">
        <table class="video-table">
            <thead>
                <tr>
                    <th>Filename</th>
                    <th>Size</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for chime in chime_files %}
                <tr style="{% if not chime.is_valid %}background-color: #ffebee;{% endif %}">
                    <td>{{ chime.filename }}</td>
                    <td>{{ chime.size_str }}</td>
                    <td>
                        {% if chime.is_valid %}
                        <span style="color: #4caf50;">‚úì Valid</span>
                        {% else %}
                        <span style="color: #f44336;" title="{{ chime.validation_msg }}">‚úó {{ chime.validation_msg[:30] }}...</span>
                        {% endif %}
                    </td>
                    <td>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <audio controls preload="none" style="height: 30px; width: 100%; max-width: 300px;">
                                <source src="{{ url_for('lock_chimes.play_lock_chime', filename=chime.filename) }}?v={{ chime.mtime }}" type="audio/wav">
                            </audio>
                            <div style="display: flex; gap: 5px; flex-wrap: wrap; align-items: center;">
                                <a href="{{ url_for('lock_chimes.download_lock_chime', filename=chime.filename) }}" class="present-btn" style="text-decoration: none; padding: 6px 12px; display: inline-flex; align-items: center; justify-content: center; border-radius: 4px; line-height: 1.5; height: 34px; box-sizing: border-box;">‚¨áÔ∏è Download</a>
                                <button type="button" class="edit-btn" onclick='editChime({{ chime.filename|tojson }})' style="padding: 6px 12px; margin: 0; font-size: 14px; height: 34px; display: inline-flex; align-items: center; justify-content: center; box-sizing: border-box;">‚úèÔ∏è Edit</button>
                                {% if chime.is_valid %}
                                <form method="post" action="{{ url_for('lock_chimes.set_as_chime', filename=chime.filename) }}" style="display: inline;" onsubmit="return handleSetChime(this);">
                                    <button type="submit" class="set-chime-btn" style="padding: 6px 12px; margin: 0; font-size: 14px; height: 34px; display: inline-flex; align-items: center; justify-content: center; box-sizing: border-box;">üîî Set as Active</button>
                                </form>
                                {% endif %}
                                <form method="post" action="{{ url_for('lock_chimes.delete_lock_chime', filename=chime.filename) }}" style="display: inline;" 
                                      onsubmit="return confirm('Are you sure you want to delete \'{{ chime.filename | replace("'", "\\'") }}\'?');">
                                    <button type="submit" class="btn-delete" style="padding: 6px 12px; margin: 0; font-size: 14px; height: 34px; display: inline-flex; align-items: center; justify-content: center; box-sizing: border-box;">üóëÔ∏è Delete</button>
                                </form>
                            </div>
                        </div>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <!-- Mobile Card Layout for Lock Chimes -->
    <div class="mobile-card-container">
        {% for chime in chime_files %}
        <div class="mobile-card" style="{% if not chime.is_valid %}border-left: 4px solid #f44336;{% endif %}">
            <div class="mobile-card-title">
                <strong>{{ chime.filename }}</strong>
            </div>
            <div class="mobile-card-info">
                <div class="mobile-card-info-row">
                    <span class="mobile-card-info-label">Size:</span>
                    <span class="mobile-card-info-value">{{ chime.size_str }}</span>
                </div>
                <div class="mobile-card-info-row">
                    <span class="mobile-card-info-label">Status:</span>
                    <span class="mobile-card-info-value">
                        {% if chime.is_valid %}
                        <span class="mobile-card-status valid">‚úì Valid</span>
                        {% else %}
                        <span class="mobile-card-status invalid" title="{{ chime.validation_msg }}">‚úó Invalid</span>
                        {% endif %}
                    </span>
                </div>
            </div>
            <div class="mobile-card-audio">
                <audio controls preload="none">
                    <source src="{{ url_for('lock_chimes.play_lock_chime', filename=chime.filename) }}?v={{ chime.mtime }}" type="audio/wav">
                </audio>
            </div>
            <div class="mobile-card-actions">
                <a href="{{ url_for('lock_chimes.download_lock_chime', filename=chime.filename) }}" class="present-btn">‚¨áÔ∏è Download</a>
                <button type="button" class="edit-btn" onclick='editChime({{ chime.filename|tojson }})'>‚úèÔ∏è Edit</button>
                {% if chime.is_valid %}
                <form method="post" action="{{ url_for('lock_chimes.set_as_chime', filename=chime.filename) }}" onsubmit="return handleSetChime(this);">
                    <button type="submit" class="set-chime-btn">üîî Set as Active</button>
                </form>
                {% endif %}
                <form method="post" action="{{ url_for('lock_chimes.delete_lock_chime', filename=chime.filename) }}" 
                      onsubmit="return confirm('Are you sure you want to delete \'{{ chime.filename | replace("'", "\\'") }}\'?');">
                    <button type="submit" class="btn-delete">üóëÔ∏è Delete</button>
                </form>
            </div>
        </div>
        {% endfor %}
    </div>
    {% else %}
    <div class="info-box">
        <p>No chimes found in the Chimes library.</p>
        <p>Upload WAV files above to add them to your library.</p>
    </div>
    {% endif %}
</div>

<!-- Loading overlay for Set as Chime operation -->
<div id="chimeLoadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; justify-content: center; align-items: center;">
    <div style="text-align: center; color: white;">
        <div class="spinner" style="border: 8px solid #f3f3f3; border-top: 8px solid #007bff; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <h3>Setting lock chime...</h3>
        <p>Please wait, this may take a few seconds</p>
    </div>
</div>

<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>

<script>
// Preserve scheduler section state across page loads
document.addEventListener('DOMContentLoaded', function() {
    const schedulerSection = document.getElementById('scheduler-section');
    const scheduleFormDetails = document.getElementById('schedule-form-details');
    
    // Check if there are any flash messages (indicates an action was just performed)
    const hasFlashMessages = document.querySelector('.flash-message') !== null;
    
    // Open scheduler section if:
    // 1. There are flash messages (user just performed an action)
    // 2. Session storage indicates it was previously open
    // 3. User manually opened it (tracked in session storage)
    const wasOpen = sessionStorage.getItem('schedulerSectionOpen') === 'true';
    
    if (hasFlashMessages || wasOpen) {
        schedulerSection.open = true;
        sessionStorage.setItem('schedulerSectionOpen', 'true');
    }
    
    // Track when user manually opens/closes the section
    schedulerSection.addEventListener('toggle', function() {
        sessionStorage.setItem('schedulerSectionOpen', schedulerSection.open ? 'true' : 'false');
    });
    
    // Similarly track the form details section
    if (scheduleFormDetails) {
        const formWasOpen = sessionStorage.getItem('scheduleFormOpen') === 'true';
        if (formWasOpen || hasFlashMessages) {
            scheduleFormDetails.open = true;
        }
        
        scheduleFormDetails.addEventListener('toggle', function() {
            sessionStorage.setItem('scheduleFormOpen', scheduleFormDetails.open ? 'true' : 'false');
        });
    }
});

function handleSetChime(form) {
    // Disable all Set as Active buttons
    const allChimeButtons = document.querySelectorAll('.set-chime-btn');
    allChimeButtons.forEach(btn => btn.disabled = true);
    
    // Show loading overlay
    document.getElementById('chimeLoadingOverlay').style.display = 'flex';
    
    return true;  // Allow form submission
}

// Handle schedule type switching
document.addEventListener('DOMContentLoaded', function() {
    const scheduleTypeRadios = document.querySelectorAll('.schedule-type-radio');
    const daysSelection = document.getElementById('days-selection');
    const dateSelection = document.getElementById('date-selection');
    const holidaySelection = document.getElementById('holiday-selection');
    const intervalSelection = document.getElementById('interval-selection');
    const timeSelection = document.getElementById('time-selection');
    const hourSelect = document.getElementById('hour-select');
    const minuteSelect = document.getElementById('minute-select');
    const ampmSelect = document.getElementById('ampm-select');
    const chimeSelect = document.getElementById('chime-select');
    
    function updateScheduleTypeFields() {
        const selectedType = document.querySelector('.schedule-type-radio:checked').value;
        
        // Hide all type-specific fields
        daysSelection.style.display = 'none';
        dateSelection.style.display = 'none';
        holidaySelection.style.display = 'none';
        intervalSelection.style.display = 'none';
        
        // Reset chime select to normal state
        chimeSelect.disabled = false;
        chimeSelect.style.pointerEvents = '';
        chimeSelect.style.opacity = '';
        chimeSelect.style.cursor = '';
        
        // Show relevant field and manage time selection/chime selection
        if (selectedType === 'weekly') {
            daysSelection.style.display = 'block';
            timeSelection.style.display = 'block';
            // Make time fields required
            hourSelect.required = true;
            minuteSelect.required = true;
            ampmSelect.required = true;
        } else if (selectedType === 'date') {
            dateSelection.style.display = 'block';
            timeSelection.style.display = 'block';
            // Make time fields required
            hourSelect.required = true;
            minuteSelect.required = true;
            ampmSelect.required = true;
        } else if (selectedType === 'holiday') {
            holidaySelection.style.display = 'block';
            // Hide time selection for holidays
            timeSelection.style.display = 'none';
            // Auto-set time to 12:00 AM and make fields not required
            hourSelect.value = '12';
            minuteSelect.value = '00';
            ampmSelect.value = 'AM';
            hourSelect.required = false;
            minuteSelect.required = false;
            ampmSelect.required = false;
        } else if (selectedType === 'recurring') {
            intervalSelection.style.display = 'block';
            // Hide time selection for recurring schedules
            timeSelection.style.display = 'none';
            // Force chime to RANDOM - don't disable so value submits
            chimeSelect.value = 'RANDOM';
            chimeSelect.style.pointerEvents = 'none';
            chimeSelect.style.opacity = '0.6';
            chimeSelect.style.cursor = 'not-allowed';
            hourSelect.required = false;
            minuteSelect.required = false;
            ampmSelect.required = false;
        }
    }
    
    // Add listeners to schedule type radios
    scheduleTypeRadios.forEach(radio => {
        radio.addEventListener('change', updateScheduleTypeFields);
    });
    
    // Initialize on page load
    updateScheduleTypeFields();
});

// Handle recurring schedule confirmation for disabling other schedules
document.addEventListener('DOMContentLoaded', function() {
    const scheduleForm = document.getElementById('schedule-form');
    if (!scheduleForm) return;
    
    scheduleForm.addEventListener('submit', async function(e) {
        const scheduleType = document.querySelector('.schedule-type-radio:checked').value;
        const enabled = document.getElementById('enabled-checkbox').checked;
        const confirmField = scheduleForm.querySelector('input[name="confirm_disable_others"]');
        
        // Only intercept for enabled recurring schedules
        if (scheduleType === 'recurring' && enabled && (!confirmField || confirmField.value !== 'true')) {
            e.preventDefault();
            
            // Submit via AJAX to check if confirmation needed
            const formData = new FormData(scheduleForm);
            
            try {
                const response = await fetch(scheduleForm.action, {
                    method: 'POST',
                    body: formData
                });
                
                // Check if response is JSON (confirmation needed) or redirect (success)
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    const data = await response.json();
                    
                    if (data.needs_confirmation) {
                        // Show confirmation dialog
                        const schedulesText = data.schedules_to_disable.map(s => `  ‚Ä¢ ${s.name}`).join('\n');
                        const confirmed = confirm(
                            `${data.message}\n\nSchedules that will be disabled:\n${schedulesText}`
                        );
                        
                        if (confirmed) {
                            // Add confirmation field and resubmit
                            const input = document.createElement('input');
                            input.type = 'hidden';
                            input.name = 'confirm_disable_others';
                            input.value = 'true';
                            scheduleForm.appendChild(input);
                            scheduleForm.submit();
                        }
                    }
                } else {
                    // Server returned HTML (redirect), reload to show result
                    window.location.reload();
                }
            } catch (error) {
                console.error('Error:', error);
                // On error, reload to show any flash messages
                window.location.reload();
            }
        }
    });
});

// Handle chime upload with progress bar
document.addEventListener('DOMContentLoaded', function() {
    const form = document.getElementById('chimeUploadForm');
    if (!form) return;
    
    form.addEventListener('submit', function(e) {
        e.preventDefault();
        
        const fileInput = document.getElementById('chime_file');
        const uploadBtn = document.getElementById('chimeUploadBtn');
        const progressDiv = document.getElementById('chimeUploadProgress');
        const progressBar = document.getElementById('chimeProgressBar');
        const statusText = document.getElementById('chimeUploadStatus');
        
        if (!fileInput.files || fileInput.files.length === 0) {
            alert('Please select a file to upload');
            return;
        }
        
        const file = fileInput.files[0];
        const formData = new FormData(form);
        
        // Disable upload button and show progress
        uploadBtn.disabled = true;
        uploadBtn.textContent = '‚è≥ Uploading...';
        progressDiv.style.display = 'block';
        
        // Create AJAX request with progress tracking
        const xhr = new XMLHttpRequest();
        
        // Track upload progress
        xhr.upload.addEventListener('progress', function(e) {
            if (e.lengthComputable) {
                const percentComplete = Math.round((e.loaded / e.total) * 100);
                progressBar.style.width = percentComplete + '%';
                progressBar.textContent = percentComplete + '%';
                statusText.textContent = `Uploading ${file.name}... (${(e.loaded / 1024).toFixed(1)} KB / ${(e.total / 1024).toFixed(1)} KB)`;
            }
        });
        
        // When upload finishes, show processing status
        xhr.upload.addEventListener('loadend', function() {
            if (xhr.readyState !== 4) {  // If request not complete yet
                progressBar.style.width = '100%';
                progressBar.textContent = 'üîÑ Processing...';
                progressBar.style.background = '#ffc107';
                statusText.textContent = 'Upload complete! Processing and validating file...';
                statusText.style.color = '#856404';
            }
        });
        
        // Handle completion
        xhr.addEventListener('load', function() {
            let response;
            try {
                response = JSON.parse(xhr.responseText);
            } catch (e) {
                response = null;
            }
            
            if (xhr.status === 200 && response && response.success) {
                progressBar.style.width = '100%';
                progressBar.textContent = '‚úì Complete';
                progressBar.style.background = '#28a745';
                
                // Show re-encoding info if present
                let successMsg = 'Upload complete!';
                if (response.reencoded && response.details) {
                    const details = response.details;
                    successMsg = `Upload successful! File was automatically re-encoded to ${details.strategy || 'Tesla format'} (${details.size_mb || '<1'} MB)`;
                }
                
                statusText.textContent = successMsg;
                statusText.style.color = '#28a745';
                
                // Redirect after short delay
                setTimeout(function() {
                    window.location.reload();
                }, 1000);
            } else {
                progressBar.style.background = '#dc3545';
                const errorMsg = response && response.error ? response.error : xhr.statusText || 'Upload failed';
                statusText.textContent = 'Upload failed: ' + errorMsg;
                statusText.style.color = '#dc3545';
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'üì§ Upload';
            }
        });
        
        // Handle errors
        xhr.addEventListener('error', function() {
            progressBar.style.background = '#dc3545';
            statusText.textContent = 'Upload failed: Network error';
            statusText.style.color = '#dc3545';
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'üì§ Upload';
        });
        
        // Send the request
        xhr.open('POST', form.action);
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');  // Mark as AJAX request
        xhr.send(formData);
    });
});

// iOS Browser Detection and Warning Display
(function() {
    // Detect iOS device
    function isIOS() {
        return /(iPad|iPhone|iPod)/i.test(navigator.userAgent) && !window.MSStream;
    }
    
    // Detect Safari (true Safari, not other browsers using WebKit on iOS)
    function isSafari() {
        var ua = navigator.userAgent;
        // Safari should have "Safari" but NOT Chrome, CriOS, EdgiOS, FxiOS, OPiOS
        return /Safari/i.test(ua) && !/Chrome|CriOS|EdgiOS|FxiOS|OPiOS/i.test(ua);
    }
    
    // Show warning and hide controls if iOS + not Safari
    if (isIOS() && !isSafari()) {
        var warning = document.getElementById('iosWarning');
        var controls = document.getElementById('chimeUploadControls');
        if (warning) warning.style.display = 'block';
        if (controls) controls.style.display = 'none';
    }
})();

// Schedule edit functionality
async function editSchedule(scheduleId) {
    try {
        // Fetch schedule data
        const response = await fetch(`/lock_chimes/schedule/${scheduleId}/edit`);
        const data = await response.json();
        
        if (!data.success) {
            alert('Error loading schedule: ' + (data.error || 'Unknown error'));
            return;
        }
        
        const schedule = data.schedule;
        
        // Populate form fields
        document.getElementById('schedule-name').value = schedule.name;
        document.getElementById('chime-select').value = schedule.chime_filename;
        
        // Set schedule type
        const scheduleTypeRadio = document.querySelector(`.schedule-type-radio[value="${schedule.schedule_type}"]`);
        if (scheduleTypeRadio) {
            scheduleTypeRadio.checked = true;
            // Trigger change event to show appropriate fields
            scheduleTypeRadio.dispatchEvent(new Event('change'));
        }
        
        // Set time (12-hour format)
        if (schedule.hour_12 && schedule.minute && schedule.am_pm) {
            document.getElementById('hour-select').value = schedule.hour_12;
            document.getElementById('minute-select').value = schedule.minute;
            document.getElementById('ampm-select').value = schedule.am_pm;
        }
        
        // Set type-specific fields
        if (schedule.schedule_type === 'weekly') {
            // Clear all day checkboxes first
            document.querySelectorAll('.day-checkbox').forEach(cb => {
                cb.checked = false;
            });
            
            // Check selected days
            schedule.days.forEach(day => {
                const checkbox = document.getElementById('day-' + day);
                if (checkbox) checkbox.checked = true;
            });
        } else if (schedule.schedule_type === 'date') {
            document.getElementById('month-select').value = schedule.month;
            document.getElementById('day-select').value = schedule.day;
        } else if (schedule.schedule_type === 'holiday') {
            document.getElementById('holiday-select').value = schedule.holiday;
        } else if (schedule.schedule_type === 'recurring') {
            document.getElementById('interval-select').value = schedule.interval;
        }
        
        // Set enabled checkbox
        document.getElementById('enabled-checkbox').checked = schedule.enabled;
        
        // Change form to edit mode
        const form = document.getElementById('schedule-form');
        form.action = `/lock_chimes/schedule/${scheduleId}/edit`;
        form.dataset.editingId = scheduleId;
        
        // Update UI
        document.getElementById('form-title').textContent = '‚úèÔ∏è Edit Schedule';
        document.getElementById('submit-btn').textContent = 'üíæ Update Schedule';
        document.getElementById('cancel-btn').style.display = 'inline-block';
        
        // Open the form
        document.getElementById('schedule-form-details').open = true;
        
        // Scroll to form
        document.getElementById('schedule-form-details').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        
    } catch (error) {
        console.error('Error loading schedule:', error);
        alert('Error loading schedule. Please try again.');
    }
}

function cancelEdit() {
    // Reset form
    const form = document.getElementById('schedule-form');
    form.reset();
    form.action = '{{ url_for("lock_chimes.add_schedule") }}';
    delete form.dataset.editingId;
    
    // Reset schedule type to weekly
    const weeklyRadio = document.querySelector('.schedule-type-radio[value="weekly"]');
    if (weeklyRadio) {
        weeklyRadio.checked = true;
        weeklyRadio.dispatchEvent(new Event('change'));
    }
    
    // Reset UI
    document.getElementById('form-title').textContent = '‚ûï Add New Schedule';
    document.getElementById('submit-btn').textContent = 'üíæ Save Schedule';
    document.getElementById('cancel-btn').style.display = 'none';
    
    // Close the form
    document.getElementById('schedule-form-details').open = false;
}

// Audio Trimmer Integration
let audioTrimmer = null;
let currentTrimFile = null;
let isEditingExistingChime = false;
let existingChimeFilenames = []; // Cache of existing filenames on server

// Fetch existing chime filenames from server
async function fetchExistingFilenames() {
    try {
        const response = await fetch('{{ url_for("api.chime_filenames") }}');
        if (response.ok) {
            const data = await response.json();
            existingChimeFilenames = data.filenames || [];
        }
    } catch (error) {
        console.warn('Failed to fetch existing filenames:', error);
        existingChimeFilenames = [];
    }
}

// Generate unique filename that doesn't conflict with existing files
function generateUniqueFilename(baseName, extension, isEditing) {
    if (!isEditing) {
        // New upload - just use the base name
        let fileName = baseName + extension;
        // If it already exists, add a number
        if (existingChimeFilenames.includes(fileName)) {
            let counter = 2;
            while (existingChimeFilenames.includes(baseName + counter + extension)) {
                counter++;
            }
            fileName = baseName + counter + extension;
        }
        return fileName;
    } else {
        // Editing existing file - add or increment _edited suffix
        const editedMatch = baseName.match(/^(.+?)_edited(\d*)$/);
        let prefix, startNum;
        
        if (editedMatch) {
            // Already has _edited suffix
            prefix = editedMatch[1];
            startNum = editedMatch[2] ? parseInt(editedMatch[2]) + 1 : 2;
        } else {
            // First time editing
            prefix = baseName;
            startNum = null; // Will try _edited first, then _edited2
        }
        
        // Find next available _editedN
        if (startNum === null) {
            let fileName = prefix + '_edited' + extension;
            if (!existingChimeFilenames.includes(fileName)) {
                return fileName;
            }
            startNum = 2;
        }
        
        let counter = startNum;
        let fileName;
        do {
            fileName = prefix + '_edited' + counter + extension;
            counter++;
        } while (existingChimeFilenames.includes(fileName));
        
        return fileName;
    }
}

// Check for Web Audio API support
if (!AudioTrimmer.isSupported()) {
    console.warn('Web Audio API not supported - trimmer disabled');
    // Fallback: show upload button, hide trim editor
    document.getElementById('chimeUploadBtn').style.display = 'inline-block';
} else {
    // Initialize trimmer
    audioTrimmer = new AudioTrimmer({
        maxFileSize: {{ MAX_LOCK_CHIME_SIZE }},
        maxDuration: {{ MAX_LOCK_CHIME_DURATION }},
        minDuration: {{ MIN_LOCK_CHIME_DURATION }},
        speedMin: {{ SPEED_RANGE_MIN }},
        speedMax: {{ SPEED_RANGE_MAX }},
        speedStep: {{ SPEED_STEP }}
    });
    
    // Fetch existing filenames on page load
    fetchExistingFilenames();
    
    // File input handler - intercept file selection
    document.getElementById('chime_file').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            isEditingExistingChime = false;
            loadAudioForTrimming(file);
        }
    });
    
    // Setup trim editor UI handlers
    setupTrimEditorUI();
}

function setupTrimEditorUI() {
    const canvas = document.getElementById('waveformCanvas');
    const startSlider = document.getElementById('startTimeSlider');
    const endSlider = document.getElementById('endTimeSlider');
    const speedSlider = document.getElementById('speedSlider');
    const playBtn = document.getElementById('playBtn');
    const autoFitBtn = document.getElementById('autoFitBtn');
    const resetBtn = document.getElementById('resetBtn');
    const uploadBtn = document.getElementById('uploadTrimmedBtn');
    const cancelBtn = document.getElementById('cancelTrimBtn');
    const normalizeCheckbox = document.getElementById('trimNormalizeVolume');
    const normalizationSettings = document.getElementById('trimNormalizationSettings');
    const targetLufsSlider = document.getElementById('trimTargetLufs');
    const currentLevelEl = document.getElementById('trimCurrentLevel');
    const levelDescriptionEl = document.getElementById('trimLevelDescription');
    
    // Volume normalization level definitions
    const volumeLevels = [
        { name: 'Broadcast', lufs: -23, description: 'Broadcast standard (quieter, more headroom)' },
        { name: 'Streaming', lufs: -16, description: 'Recommended for balanced playback' },
        { name: 'Loud', lufs: -14, description: 'Louder output (less dynamic range)' },
        { name: 'Maximum', lufs: -12, description: 'Maximum loudness (may clip on some systems)' }
    ];
    
    // Set canvas size based on container
    function resizeCanvas() {
        const container = canvas.parentElement;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = container.clientWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        canvas.style.width = container.clientWidth + 'px';
        
        if (audioTrimmer && audioTrimmer.audioBuffer) {
            audioTrimmer.renderWaveform(canvas);
        }
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // Slider handlers
    startSlider.addEventListener('input', function() {
        if (!audioTrimmer || !audioTrimmer.audioBuffer) return;
        const duration = audioTrimmer.audioBuffer.duration;
        const startTime = (parseFloat(this.value) / 100) * duration;
        audioTrimmer.setTrimRegion(startTime, audioTrimmer.endTime);
        updateTrimUI();
    });
    
    endSlider.addEventListener('input', function() {
        if (!audioTrimmer || !audioTrimmer.audioBuffer) return;
        const duration = audioTrimmer.audioBuffer.duration;
        const endTime = (parseFloat(this.value) / 100) * duration;
        audioTrimmer.setTrimRegion(audioTrimmer.startTime, endTime);
        updateTrimUI();
    });
    
    speedSlider.addEventListener('input', function() {
        if (!audioTrimmer) return;
        audioTrimmer.setPlaybackSpeed(parseFloat(this.value));
        updateTrimUI();
    });
    
    // Volume normalization checkbox
    normalizeCheckbox.addEventListener('change', async function() {
        normalizationSettings.style.display = this.checked ? 'block' : 'none';
        
        if (!audioTrimmer) return;
        
        // Update trimmer normalization settings
        if (this.checked) {
            const sliderIndex = parseInt(targetLufsSlider.value);
            const targetLufs = volumeLevels[sliderIndex].lufs;
            audioTrimmer.setNormalization(true, targetLufs);
            
            // Calculate and display gain
            await audioTrimmer.calculateNormalizationGain();
            updateTrimUI();
        } else {
            audioTrimmer.setNormalization(false);
            updateTrimUI();
        }
    });
    
    // Volume normalization slider
    targetLufsSlider.addEventListener('input', async function() {
        const level = volumeLevels[parseInt(this.value)];
        currentLevelEl.textContent = level.name;
        levelDescriptionEl.textContent = level.description;
        
        // Update trimmer with new target LUFS
        if (audioTrimmer && normalizeCheckbox.checked) {
            audioTrimmer.setNormalization(true, level.lufs);
            await audioTrimmer.calculateNormalizationGain();
            updateTrimUI();
        }
    });
    
    // Filename validation
    const trimFilenameInput = document.getElementById('trimFilename');
    const filenameValidation = document.getElementById('filenameValidation');
    
    function validateFilename() {
        if (!trimFilenameInput || !filenameValidation) return true;
        
        const value = trimFilenameInput.value.trim();
        if (!value) {
            filenameValidation.style.display = 'none';
            return true;
        }
        
        // Add .wav if not present
        const fileName = value.endsWith('.wav') ? value : value + '.wav';
        const lowerFileName = fileName.toLowerCase();
        
        // Check for invalid characters
        const invalidChars = /[<>:"|?*\/\\]/;
        if (invalidChars.test(value)) {
            filenameValidation.textContent = '‚ùå Filename contains invalid characters';
            filenameValidation.style.color = '#f44336';
            filenameValidation.style.display = 'block';
            return false;
        }
        
        // Check if it already exists
        if (existingChimeFilenames.some(f => f.toLowerCase() === lowerFileName)) {
            filenameValidation.textContent = '‚ùå This filename already exists';
            filenameValidation.style.color = '#f44336';
            filenameValidation.style.display = 'block';
            return false;
        }
        
        filenameValidation.textContent = '‚úÖ Filename available';
        filenameValidation.style.color = '#4CAF50';
        filenameValidation.style.display = 'block';
        return true;
    }
    
    if (trimFilenameInput) {
        trimFilenameInput.addEventListener('input', validateFilename);
        trimFilenameInput.addEventListener('blur', validateFilename);
    }
    
    // Play button
    playBtn.addEventListener('click', function() {
        if (!audioTrimmer) return;
        if (audioTrimmer.isPlaying) {
            audioTrimmer.stopPreview();
            playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
            playBtn.classList.remove('playing');
        } else {
            audioTrimmer.playPreview();
            playBtn.innerHTML = '<i class="bi bi-stop-fill"></i>';
            playBtn.classList.add('playing');
            // Auto-reset after playback
            setTimeout(() => {
                if (!audioTrimmer.isPlaying) {
                    playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
                    playBtn.classList.remove('playing');
                }
            }, (audioTrimmer.endTime - audioTrimmer.startTime) / audioTrimmer.playbackSpeed * 1000 + 100);
        }
    });
    
    // Auto-fit button
    autoFitBtn.addEventListener('click', function() {
        if (!audioTrimmer) return;
        const result = audioTrimmer.autoFit();
        if (result) {
            updateTrimUI();
            showTrimMessage(result.message, result.trimmed ? 'warning' : 'success');
        }
    });
    
    // Reset button
    resetBtn.addEventListener('click', function() {
        if (!audioTrimmer || !audioTrimmer.audioBuffer) return;
        const duration = audioTrimmer.audioBuffer.duration;
        audioTrimmer.setTrimRegion(0, Math.min(duration, audioTrimmer.maxDuration));
        audioTrimmer.setPlaybackSpeed(1.0);
        updateTrimUI();
        showTrimMessage('Reset to original settings', 'info');
    });
    
    // Upload button
    uploadBtn.addEventListener('click', async function() {
        if (!audioTrimmer) return;
        
        try {
            uploadBtn.disabled = true;
            uploadBtn.textContent = '‚è≥ Processing...';
            
            // Refresh filename list to check for collisions
            await fetchExistingFilenames();
            
            // Get filename input (declare once at the top)
            const customFilenameInput = document.getElementById('trimFilename');
            const hasCustomFilename = customFilenameInput && customFilenameInput.value.trim();
            
            // Check if this is edit mode with only filename change (no audio modifications)
            if (isEditingExistingChime && hasCustomFilename && !audioTrimmer.hasAudioBeenModified()) {
                // Rename only - no need to re-encode
                const customName = customFilenameInput.value.trim();
                const newFilename = customName.endsWith('.wav') ? customName : customName + '.wav';
                
                // Validate filename
                const invalidChars = /[<>:"|?*\/\\]/;
                if (invalidChars.test(customName)) {
                    showTrimMessage('Filename contains invalid characters. Please use only letters, numbers, spaces, hyphens, and underscores.', 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                    return;
                }
                
                // Check for collisions
                const lowerFileName = newFilename.toLowerCase();
                if (existingChimeFilenames.some(f => f.toLowerCase() === lowerFileName)) {
                    showTrimMessage(`Filename "${newFilename}" already exists. Please choose a different name.`, 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                    return;
                }
                
                // Perform rename via API
                uploadBtn.textContent = 'üìù Renaming...';
                const response = await fetch(`/api/rename_chime/${encodeURIComponent(audioTrimmer.originalFileName)}/${encodeURIComponent(newFilename)}`, {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showTrimMessage('File renamed successfully!', 'success');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } else {
                    showTrimMessage('Rename failed: ' + (result.error || 'Unknown error'), 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                }
                return;
            }
            
            // Full upload with audio processing
            // Export as WAV (Tesla requirement)
            const wavBlob = await audioTrimmer.exportWAV();
            
            // Check actual file size
            if (wavBlob.size > {{ MAX_LOCK_CHIME_SIZE }}) {
                const actualSizeMB = (wavBlob.size / 1024 / 1024).toFixed(2);
                showTrimMessage(`Pre-trimmed file validation failed: File is ${actualSizeMB} MB. Tesla requires lock chimes to be under 1 MB. ['success':false]`, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                return;
            }
            
            // Create FormData and submit
            const formData = new FormData();
            
            // Determine final filename
            let fileName;
            
            if (hasCustomFilename) {
                // Use custom filename (add .wav extension)
                const customName = customFilenameInput.value.trim();
                
                // Check for invalid characters
                const invalidChars = /[<>:"|?*\/\\]/;
                if (invalidChars.test(customName)) {
                    showTrimMessage('Filename contains invalid characters. Please use only letters, numbers, spaces, hyphens, and underscores.', 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                    return;
                }
                
                fileName = customName.endsWith('.wav') ? customName : customName + '.wav';
                
                // Validate it doesn't already exist (case-insensitive)
                const lowerFileName = fileName.toLowerCase();
                if (existingChimeFilenames.some(f => f.toLowerCase() === lowerFileName)) {
                    showTrimMessage(`Filename "${fileName}" already exists. Please choose a different name.`, 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                    return;
                }
            } else {
                // Generate filename based on whether this is a new upload or editing existing
                let baseName = audioTrimmer.originalFileName.replace(/\.[^.]+$/, '');
                fileName = generateUniqueFilename(baseName, '.wav', isEditingExistingChime);
            }
            
            console.log('Original filename:', audioTrimmer.originalFileName);
            console.log('Editing existing:', isEditingExistingChime);
            console.log('Final filename:', fileName);
            formData.append('chime_file', wavBlob, fileName);
            formData.append('pre_trimmed', 'true'); // WAV already in correct format and normalized in browser
            formData.append('original_filename', audioTrimmer.originalFileName);
            
            // Note: Normalization is now done client-side in the browser
            // The uploaded WAV blob already has normalization applied if enabled
            
            // Submit via fetch
            const response = await fetch('{{ url_for("lock_chimes.upload_lock_chime") }}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: formData
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    // Reload page to show new chime
                    window.location.reload();
                } else {
                    showTrimMessage('Upload failed: ' + (result.error || 'Unknown error'), 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
                }
            } else {
                const text = await response.text();
                showTrimMessage('Upload failed: ' + text, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
            }
        } catch (error) {
            console.error('Upload error:', error);
            showTrimMessage('Upload failed: ' + error.message, 'error');
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'üì§ Upload Trimmed Audio';
        }
    });
    
    // Cancel button
    cancelBtn.addEventListener('click', function() {
        closeTrimEditor();
    });
}

function loadAudioForTrimming(file) {
    if (!audioTrimmer) return;
    
    // Show editor section
    document.getElementById('trimEditorSection').style.display = 'block';
    document.getElementById('trimEditorLoading').style.display = 'block';
    document.getElementById('trimEditorContent').style.display = 'none';
    document.getElementById('chimeUploadControls').open = false;
    
    // Load audio
    audioTrimmer.loadFile(file).then(async result => {
        if (result.success) {
            currentTrimFile = file.name;
            document.getElementById('trimEditorLoading').style.display = 'none';
            document.getElementById('trimEditorContent').style.display = 'block';
            
            // Pre-populate filename field with base name (no extension)
            const trimFilenameInput = document.getElementById('trimFilename');
            if (trimFilenameInput) {
                const baseName = file.name.replace(/\.[^.]+$/, '');
                trimFilenameInput.value = baseName;
                // Clear validation message
                const filenameValidation = document.getElementById('filenameValidation');
                if (filenameValidation) {
                    filenameValidation.style.display = 'none';
                }
            }
            
            // Apply normalization settings if checkbox is checked
            const normalizeCheckbox = document.getElementById('trimNormalizeVolume');
            const targetLufsSlider = document.getElementById('trimTargetLufs');
            if (normalizeCheckbox && normalizeCheckbox.checked && targetLufsSlider) {
                const sliderIndex = parseInt(targetLufsSlider.value);
                const volumeLevels = [
                    { name: "Very Quiet", lufs: -23, description: "Barely audible" },
                    { name: "Quiet", lufs: -18, description: "Soft and subtle" },
                    { name: "Normal", lufs: -14, description: "Standard loudness" },
                    { name: "Loud", lufs: -11, description: "Attention-grabbing" },
                    { name: "Very Loud", lufs: -9, description: "Maximum volume" }
                ];
                audioTrimmer.setNormalization(true, volumeLevels[sliderIndex].lufs);
                await audioTrimmer.calculateNormalizationGain();
            }
            
            // Wait for layout to update, then resize and render canvas
            setTimeout(() => {
                const canvas = document.getElementById('waveformCanvas');
                const container = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                canvas.width = container.clientWidth * dpr;
                canvas.height = canvas.offsetHeight * dpr;
                canvas.style.width = container.clientWidth + 'px';
                
                audioTrimmer.renderWaveform(canvas);
                updateTrimUI();
            }, 100);
            
            // Scroll to editor
            document.getElementById('trimEditorSection').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            showTrimMessage('Failed to decode audio: ' + result.error, 'error');
            closeTrimEditor();
        }
    });
}

function editChime(filename) {
    if (!audioTrimmer) {
        alert('Audio trimmer not available');
        return;
    }
    
    isEditingExistingChime = true;
    currentTrimFile = filename;
    
    // Show editor section
    document.getElementById('trimEditorSection').style.display = 'block';
    document.getElementById('trimEditorSection').classList.add('edit-mode');
    document.getElementById('trimEditorLoading').style.display = 'block';
    document.getElementById('trimEditorContent').style.display = 'none';
    document.getElementById('trimEditorBadge').style.display = 'inline-block';
    document.getElementById('trimEditorBadge').textContent = 'Editing: ' + filename;
    
    // Pre-populate filename field with _edited suffix suggestion
    const trimFilenameInput = document.getElementById('trimFilename');
    if (trimFilenameInput) {
        const baseName = filename.replace(/\.[^.]+$/, '');
        const suggestedName = generateUniqueFilename(baseName, '.wav', true).replace('.wav', '');
        trimFilenameInput.value = suggestedName;
        // Clear validation message
        const filenameValidation = document.getElementById('filenameValidation');
        if (filenameValidation) {
            filenameValidation.style.display = 'none';
        }
    }
    
    // Load audio from server
    const url = '{{ url_for("lock_chimes.play_lock_chime", filename="PLACEHOLDER") }}'.replace('PLACEHOLDER', filename);
    
    audioTrimmer.loadFile(url, filename).then(async result => {
        if (result.success) {
            document.getElementById('trimEditorLoading').style.display = 'none';
            document.getElementById('trimEditorContent').style.display = 'block';
            
            // Apply normalization settings if checkbox is checked
            const normalizeCheckbox = document.getElementById('trimNormalizeVolume');
            const targetLufsSlider = document.getElementById('trimTargetLufs');
            if (normalizeCheckbox && normalizeCheckbox.checked && targetLufsSlider) {
                const sliderIndex = parseInt(targetLufsSlider.value);
                const volumeLevels = [
                    { name: "Very Quiet", lufs: -23, description: "Barely audible" },
                    { name: "Quiet", lufs: -18, description: "Soft and subtle" },
                    { name: "Normal", lufs: -14, description: "Standard loudness" },
                    { name: "Loud", lufs: -11, description: "Attention-grabbing" },
                    { name: "Very Loud", lufs: -9, description: "Maximum volume" }
                ];
                audioTrimmer.setNormalization(true, volumeLevels[sliderIndex].lufs);
                await audioTrimmer.calculateNormalizationGain();
            }
            
            // Wait for layout to update, then resize and render canvas
            setTimeout(() => {
                const canvas = document.getElementById('waveformCanvas');
                const container = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                canvas.width = container.clientWidth * dpr;
                canvas.height = canvas.offsetHeight * dpr;
                canvas.style.width = container.clientWidth + 'px';
                
                audioTrimmer.renderWaveform(canvas);
                updateTrimUI();
            }, 100);
            
            // Scroll to editor
            updateTrimUI();
            
            // Scroll to editor
            document.getElementById('trimEditorSection').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            showTrimMessage('Failed to load audio: ' + result.error, 'error');
            closeTrimEditor();
        }
    });
}

function updateTrimUI() {
    if (!audioTrimmer || !audioTrimmer.audioBuffer) return;
    
    const stats = audioTrimmer.getStats();
    const duration = audioTrimmer.audioBuffer.duration;
    
    // Update sliders
    document.getElementById('startTimeSlider').value = (stats.startTime / duration) * 100;
    document.getElementById('endTimeSlider').value = (stats.endTime / duration) * 100;
    document.getElementById('speedSlider').value = stats.playbackSpeed;
    
    // Update displays to show OUTPUT timeline (speed-adjusted time values)
    // The trim markers stay at same visual position, but the time labels update
    const outputStartTime = stats.startTime / stats.playbackSpeed;
    const outputEndTime = stats.endTime / stats.playbackSpeed;
    document.getElementById('startTimeDisplay').textContent = outputStartTime.toFixed(2) + 's';
    document.getElementById('endTimeDisplay').textContent = outputEndTime.toFixed(2) + 's';
    document.getElementById('speedDisplay').innerHTML = stats.playbackSpeed !== 1.0 
        ? '<span class="speed-badge">' + stats.playbackSpeed.toFixed(2) + 'x</span>' 
        : stats.playbackSpeed.toFixed(2) + 'x';
    
    // Update stats
    document.getElementById('statDuration').textContent = stats.trimDuration.toFixed(2) + 's';
    document.getElementById('statEffective').textContent = stats.effectiveDuration.toFixed(2) + 's';
    
    // Use actual file size if available, otherwise use estimate
    const fileSize = stats.actualFileSize || stats.estimatedFileSize;
    const fileSizeKB = (fileSize / 1024).toFixed(1);
    const fileSizeMB = (fileSize / 1024 / 1024).toFixed(2);
    const sizeText = fileSize < 1024 * 100 ? fileSizeKB + ' KB' : fileSizeMB + ' MB';
    document.getElementById('statFileSize').textContent = stats.actualFileSize ? sizeText : '~' + sizeText;
    
    // Update status
    const statusEl = document.getElementById('statFileSize');
    const statusTextEl = document.getElementById('statStatus');
    
    statusEl.classList.remove('success', 'warning', 'error');
    statusTextEl.classList.remove('success', 'warning', 'error');
    
    const withinLimit = fileSize <= {{ MAX_LOCK_CHIME_SIZE }};
    
    if (!withinLimit) {
        statusEl.classList.add('error');
        statusTextEl.classList.add('error');
        statusTextEl.textContent = '‚úó Too Large';
    } else if (fileSize > {{ MAX_LOCK_CHIME_SIZE }} * 0.9) {
        statusEl.classList.add('warning');
        statusTextEl.classList.add('warning');
        statusTextEl.textContent = '‚ö† Close to Limit';
    } else {
        statusEl.classList.add('success');
        statusTextEl.classList.add('success');
        statusTextEl.textContent = '‚úì Ready';
    }
    
    // Recalculate actual size periodically to update UI (debounced)
    clearTimeout(window.trimUIUpdateTimeout);
    window.trimUIUpdateTimeout = setTimeout(async () => {
        try {
            const accurateStats = await audioTrimmer.getStatsWithActualSize();
            if (accurateStats) {
                // Update file size display with actual value
                const actualFileSize = accurateStats.actualFileSize;
                const actualFileSizeKB = (actualFileSize / 1024).toFixed(1);
                const actualFileSizeMB = (actualFileSize / 1024 / 1024).toFixed(2);
                const actualSizeText = actualFileSize < 1024 * 100 ? actualFileSizeKB + ' KB' : actualFileSizeMB + ' MB';
                document.getElementById('statFileSize').textContent = actualSizeText;
                
                // Update status based on actual size
                const withinActualLimit = actualFileSize <= {{ MAX_LOCK_CHIME_SIZE }};
                
                statusEl.classList.remove('success', 'warning', 'error');
                statusTextEl.classList.remove('success', 'warning', 'error');
                
                if (!withinActualLimit) {
                    statusEl.classList.add('error');
                    statusTextEl.classList.add('error');
                    statusTextEl.textContent = '‚úó Too Large';
                } else if (actualFileSize > {{ MAX_LOCK_CHIME_SIZE }} * 0.9) {
                    statusEl.classList.add('warning');
                    statusTextEl.classList.add('warning');
                    statusTextEl.textContent = '‚ö† Close to Limit';
                } else {
                    statusEl.classList.add('success');
                    statusTextEl.classList.add('success');
                    statusTextEl.textContent = '‚úì Ready';
                }
            }
        } catch (error) {
            console.error('Error updating actual file size:', error);
        }
    }, 500); // Wait 500ms after user stops adjusting
}

function showTrimMessage(message, type) {
    const messageEl = document.getElementById('trimMessage');
    messageEl.textContent = message;
    messageEl.className = 'trim-message ' + type;
    messageEl.style.display = 'block';
    
    // Auto-hide success/info messages
    if (type === 'success' || type === 'info') {
        setTimeout(() => {
            messageEl.style.display = 'none';
        }, 5000);
    }
}

function closeTrimEditor() {
    // Stop playback
    if (audioTrimmer && audioTrimmer.isPlaying) {
        audioTrimmer.stopPreview();
    }
    
    // Hide editor
    document.getElementById('trimEditorSection').style.display = 'none';
    document.getElementById('trimEditorSection').classList.remove('edit-mode');
    document.getElementById('trimEditorBadge').style.display = 'none';
    document.getElementById('trimMessage').style.display = 'none';
    
    // Reset file input
    document.getElementById('chime_file').value = '';
    
    // Reset state
    isEditingExistingChime = false;
    currentTrimFile = null;
    
    // Reset play button
    const playBtn = document.getElementById('playBtn');
    playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
    playBtn.classList.remove('playing');
}
</script>

<style>
/* Rotate arrow when details is open */
details[open] > summary > span:first-child {
    transform: rotate(90deg);
    display: inline-block;
}

details > summary > span:first-child {
    transition: transform 0.2s;
    display: inline-block;
}

/* Remove default marker */
details > summary {
    list-style: none;
}

details > summary::-webkit-details-marker {
    display: none;
}
</style>

<script>
// Check gadget state on page load
document.addEventListener('DOMContentLoaded', function() {
    checkGadgetState();
});

async function checkGadgetState() {
    try {
        const response = await fetch('/api/gadget_state');
        const state = await response.json();
        
        const indicator = document.getElementById('gadgetStateIndicator');
        const title = document.getElementById('gadgetStateTitle');
        const details = document.getElementById('gadgetStateDetails');
        
        if (!state.healthy) {
            // Show warning state
            indicator.style.display = 'block';
            indicator.style.background = 'var(--warning-bg, #fff3cd)';
            indicator.style.borderLeft = '4px solid var(--warning-border, #ffc107)';
            indicator.style.color = 'var(--text-primary)';
            
            title.textContent = '‚ö†Ô∏è Gadget State Issues Detected';
            title.style.color = 'var(--text-primary)';
            
            let detailsHtml = '<ul style="margin: 5px 0 0 20px; padding: 0; color: var(--text-primary);">';
            state.issues_found.forEach(issue => {
                detailsHtml += `<li>${issue}</li>`;
            });
            detailsHtml += '</ul>';
            
            if (state.fixes_applied.length > 0) {
                detailsHtml += '<div style="margin-top: 5px; color: var(--success-text, #28a745); font-weight: 600;">‚úì Auto-fixed: ' + state.fixes_applied.join(', ') + '</div>';
            }
            
            if (state.errors.length > 0) {
                detailsHtml += '<div style="margin-top: 5px; color: var(--error-text, #dc3545); font-weight: 600;">‚úó Errors: ' + state.errors.join(', ') + '</div>';
                detailsHtml += '<div style="margin-top: 5px; font-size: 12px; color: var(--text-secondary);">Tip: Switch to Edit mode and back to Present mode to reset gadget state.</div>';
            }
            
            details.innerHTML = detailsHtml;
            
        } else if (state.fixes_applied.length > 0) {
            // Show success state (issues were found and fixed)
            indicator.style.display = 'block';
            indicator.style.background = 'var(--success-bg, #d4edda)';
            indicator.style.borderLeft = '4px solid var(--success-border, #28a745)';
            indicator.style.color = 'var(--text-primary)';
            
            title.textContent = '‚úì Gadget State Recovered';
            details.innerHTML = '<div style="color: var(--success-text, #28a745);">Fixed: ' + state.fixes_applied.join(', ') + '</div>';
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 10000);
        }
        // If healthy and no fixes, don't show indicator
        
    } catch (error) {
        console.error('Error checking gadget state:', error);
    }
}
</script>
{% endblock %}
